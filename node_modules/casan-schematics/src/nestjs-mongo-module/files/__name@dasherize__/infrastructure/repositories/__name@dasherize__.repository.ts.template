import { <%= classify(name) %>RepositoryInterface } from '../../domain/repositories/<%= dasherize(name) %>.repository.interface';
import { <%= classify(name) %>Entity } from '../../domain/entities/<%= dasherize(name) %>.entity';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types } from 'mongoose';
import { <%= classify(name) %> } from '../persistence/<%= dasherize(name) %>.schema';
import { plainToInstance } from 'class-transformer';
import { CommonUtil } from 'src/common/presentation/utils/common.util';

export class <%= classify(name) %>Repository implements <%= classify(name) %>RepositoryInterface {
  constructor(
    @InjectModel('<%= classify(name) %>')
    private readonly <%= dasherize(name) %>Model: Model<<%= classify(name) %>>,
  ) {}

  async save(<%= dasherize(name) %>: <%= classify(name) %>Entity): Promise<<%= classify(name) %>Entity> {
    const created<%= classify(name) %> = new this.<%= dasherize(name) %>Model(<%= dasherize(name) %>);

    const saved<%= classify(name) %> = await created<%= classify(name) %>.save();
    return this.mapToEntity(saved<%= classify(name) %>);
  }

  async findById(id: string): Promise<<%= classify(name) %>Entity | null> {
    // แปลง id ที่รับเข้ามาให้เป็น ObjectId ก่อนใช้ในการค้นหา
    if (!Types.ObjectId.isValid(id)) {
      return null; // หรือสามารถโยนข้อผิดพลาดกลับไปได้เช่นกัน
    }
    const objectId = new Types.ObjectId(id);
    const <%= dasherize(name) %> = await this.<%= dasherize(name) %>Model.findById(objectId).exec();
    return <%= dasherize(name) %> ? this.mapToEntity(<%= dasherize(name) %>) : null;
  }

  async findByName(name: string): Promise<<%= classify(name) %>Entity | null> {
    const <%= dasherize(name) %> = await this.<%= dasherize(name) %>Model.findOne({ name }).exec();
    return <%= dasherize(name) %> ? this.mapToEntity(<%= dasherize(name) %>) : null;
  }

  async findAllPaginated(
    page: number,
    limit: number,
    sortBy: string,
    sortType: string,
    keyword: string,
    companyId: string,
  ): Promise<{ data: <%= classify(name) %>Entity[]; totalCount: number }> {
    const skip = (page - 1) * limit;
    const sortOption: { [key: string]: 1 | -1 } = {
      [sortBy]: sortType === 'asc' ? 1 : -1,
    }; // การจัดเรียงตามฟิลด์ที่ระบุ

    const filter: any = { companyId: companyId};

    // Add keyword filter if provided
    if (keyword) {
      filter.$or = [
        {
          name: {
            $regex: CommonUtil.escapeRegExp(keyword),
            $options: 'i',
          },
        },
      ];
    }

    // Fetch total count
    const totalCount = await this.<%= dasherize(name) %>Model.countDocuments(filter);

    const <%= dasherize(name) %>s = await this.<%= dasherize(name) %>Model
      .find(filter)
      .sort(sortOption)
      .skip(skip)
      .limit(limit)
      .exec();
    
    return {
      data: <%= dasherize(name) %>s.map((t) => this.mapToEntity(t)),
      totalCount,
    };
  }

  async count(): Promise<number> {
    return this.<%= dasherize(name) %>Model.countDocuments().exec();
  }

  async update(<%= dasherize(name) %>: <%= classify(name) %>Entity): Promise<<%= classify(name) %>Entity> {
    const updated<%= classify(name) %> = await this.<%= dasherize(name) %>Model.findByIdAndUpdate(<%= dasherize(name) %>.id, <%= dasherize(name) %>);

    return this.mapToEntity(updated<%= classify(name) %>);
  }

  async delete(id: string): Promise<void> {
    await this.<%= dasherize(name) %>Model.findByIdAndDelete(id);
  }

  private mapToEntity(<%= dasherize(name) %>: any): <%= classify(name) %>Entity {
    const plainObject = <%= dasherize(name) %>.toObject();
    const entity = plainToInstance(<%= classify(name) %>Entity, plainObject, {
      excludeExtraneousValues: true,
    });

    return entity;
  }
}
